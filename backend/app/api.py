from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import Optional

from app.agents.worklow import AgentWorklow
from app.agents.state_manager import StateManager
from app.agents.tools.knowledgebase import KnowledgeBase
from app.core.logging import get_logger
from services.screen_service import ScreenService

logger = get_logger(__name__)


class ChatRequest(BaseModel):
    """Request model for chat endpoint"""
    message: str
    session_id: Optional[str] = None


class SessionResponse(BaseModel):
    """Response model for session creation"""
    session_id: str


class ChatResponse(BaseModel):
    """Response model for non-streaming chat"""
    response: str
    session_id: str

@asynccontextmanager
async def lifespan(_: FastAPI):
    logger.info("Starting Agentic Workflow API...")
    logger.info("LangGraph workflow initialized and ready")

    yield

    state_manager.clear_expired()
    logger.info("Shutting down Agentic Workflow API...")


app = FastAPI(
    title="Agentic Workflow API",
    description="LangGraph-based agentic workflow with streaming support",
    version="1.0.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        'http://localhost:3000'
    ],
    allow_credentials = True,
    allow_methods=['GET', 'POST', 'DELETE', 'OPTIONS'],
    allow_headers=['*']
)

state_manager = StateManager(ttl=30)
screen_service = ScreenService()
knowledge_base = KnowledgeBase(screen_service)
agent_workflow = AgentWorklow(knowledge_base, state_manager)


@app.get("/")
async def root():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "Agentic Workflow API",
        "version": "1.0.0"
    }


@app.post("/session", response_model=SessionResponse)
async def create_session():
    """
    Create a new chat session
    
    Returns:
        SessionResponse with the new session_id
    """
    try:
        session_id = agent_workflow.start_session()
        logger.info(f"New session created: {session_id}")
        return SessionResponse(session_id=session_id)
    except Exception as e:
        logger.error(f"Error creating session: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/chat")
async def chat(request: ChatRequest) -> ChatResponse:
    """
    Non-streaming chat endpoint
    
    Args:
        request: ChatRequest with message and optional session_id
        
    Returns:
        ChatResponse with the agent's response
    """
    try:
        # Create session if not provided
        session_id = request.session_id
        if not session_id:
            session_id = agent_workflow.start_session()
            logger.info(f"Created new session: {session_id}")
        
        # Process message
        response = agent_workflow.process_message(session_id, request.message)
        
        return ChatResponse(
            response=response,
            session_id=session_id
        )
        
    except ValueError as e:
        logger.error(f"Invalid session: {e}")
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Error processing chat: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/chat/stream")
async def chat_stream(request: ChatRequest):
    """
    Streaming chat endpoint - streams tokens as they arrive from OpenAI
    
    This endpoint uses Server-Sent Events (SSE) to stream the response
    in real-time as tokens are generated by the LLM.
    
    Args:
        request: ChatRequest with message and optional session_id
        
    Returns:
        StreamingResponse with text/event-stream content type
        
    Example usage with curl:
        curl -X POST http://localhost:8000/chat/stream \
          -H "Content-Type: application/json" \
          -d '{"message": "Add a dashboard for order management system", "session_id": "xxx"}' \
          --no-buffer
    
    Example usage with Python requests:
        import requests
        
        response = requests.post(
            "http://localhost:8000/chat/stream",
            json={"message": "Add a dashboard", "session_id": "xxx"},
            stream=True
        )
        
        for chunk in response.iter_content(chunk_size=None, decode_unicode=True):
            print(chunk, end='', flush=True)
    """
    try:
        session_id = request.session_id
        if not session_id:
            session_id = agent_workflow.start_session()
            logger.info(f"Created new session for streaming: {session_id}")
        
        async def generate_stream():
            try:
                yield '{"role": "assistant", "content": "START"}\n\n'

                async for token in agent_workflow.stream_process_message(
                    session_id, 
                    request.message
                ):
                    yield f'{{"role": "assistant", "content": "{token}"}}\n\n'
                
                yield '{"role": "assistant", "content": "END"}\n\n'
                
            except Exception as e:
                logger.error(f"Error in stream generation: {e}")
                yield f'{{"role": "assistant", "content": "{e}"}}\n\n'
        
        return StreamingResponse(
            generate_stream(),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no",  # Disable nginx buffering
            }
        )
        
    except ValueError as e:
        logger.error(f"Invalid session: {e}")
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(f"Error in streaming chat: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/session/{session_id}")
async def delete_session(session_id: str):
    """
    Delete a session (clear expired sessions)
    
    Args:
        session_id: The session ID to validate
        
    Returns:
        Status message
    """
    try:
        state_manager.clear_expired()
        return {"status": "success", "message": "Expired sessions cleared"}
    except Exception as e:
        logger.error(f"Error clearing sessions: {e}")
        raise HTTPException(status_code=500, detail=str(e))



